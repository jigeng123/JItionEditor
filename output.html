<!DOCTYPE html>

<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>JIgengæ–‡æœ¬ç¼–è¾‘å™¨</title>
    <!-- Prism.js (ä»£ç é«˜äº®) -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <!-- html2pdf (å‰ç«¯ PDF å¯¼å‡º) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.min.js"></script>
    <!-- markdown-it + turndown -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/turndown/dist/turndown.min.js"></script>
    <!-- å…¨å±€æ§åˆ¶.css -->
    <style>
      /* ====ğŸ¨ å…¨å±€å˜é‡å®šä¹‰ (ä¸»é¢˜é¢œè‰²ç­‰)===== */
      /* æ¯ä¸ªåŒºå—é¢œè‰²,æœ‰ä¸‰ç§,é‡ä¸­æµ…,ä»¥ä¾¿ä½¿ç”¨ */
      /* èƒŒæ™¯è‰² */
      :root {
        --bg: #191919;
        --bg1: #525252;
        --bg2: #b5b5b5;
      }
      /* æ–‡å­— (ä¸èƒŒæ™¯ç›¸å)*/
      :root {
        --text: #fcfcfc;
        --text1: #5a5a5a;
        --text2: #272727;
      }
      /* é«˜äº®è‰² */
      :root {
        --hi: #d43ba1;
        --hi1: #6942b1;
        --hi2: #8bff3d;
      }

      /* boxçš„å°ºå¯¸,ä»¥è¾¹ç¼˜boxä¸ºå‡†,ä»¥å…å¤–æ‰©å¯¼è‡´ä¸å¿…è¦çš„è®¡ç®— */
      * {
        box-sizing: border-box;
      }

      /* å¦‚æœæœ‰è·³è½¬,ä¼šå¹³æ»‘æ»šåŠ¨ */
      html {
        scroll-behavior: smooth;
      }
    </style>
    <!-- body -->
    <style>
      /* æ•´ä½“çš„å­—ä½“,marginå¤–è¾¹è·,borderè¾¹ç¼˜,paddingå†…è¾¹è·,èƒŒæ™¯,æ–‡å­—é¢œè‰² */
      /* è¾¹è·æ¥å—å››ä¸ªå€¼(é¡ºæ—¶é’ˆ,ä¸Šå³ä¸‹å·¦),ä¸¤ä¸ªå€¼ä¸ºä¸Šä¸‹/å·¦å³,ä¸€ä¸ªå€¼ä¸ºå››å‘¨æ‰€æœ‰ */
      body {
        font-family: system-ui;
        margin: 0px;
        background: var(--hi);
        color: var(--text);
      }
      .block:hover:not(:has(.block:hover)) {
        box-shadow: 0 0 0 1.5px rgba(149, 255, 92, 0.6);
        border-radius: 10px;
        transition: box-shadow 0.2s ease;
      }

      /* ç¼–è¾‘çŠ¶æ€ */
      .block .content:focus {
        box-shadow: 0 0 0 1.5px rgba(85, 184, 255, 0.8);
        border-radius: 4px;
        transition: box-shadow 0.2s ease;
      }
      /*
 * æ ¸å¿ƒæ ·å¼ï¼šä¸ºå†…å®¹ä¸ºç©ºçš„ contenteditable å…ƒç´ æ˜¾ç¤ºå ä½ç¬¦
 */
      [contenteditable="true"]:empty::before {
        /* ä½¿ç”¨ attr() å‡½æ•°è¯»å– data-placeholder å±æ€§çš„å€¼ä½œä¸ºå†…å®¹ */
        content: attr(data-placeholder);

        /* è®¾ç½®å ä½ç¬¦çš„æ ·å¼ï¼Œä½¿å…¶çœ‹èµ·æ¥åƒæç¤ºæ–‡å­— */
        color: #aaa; /* ç°è‰²å­—ä½“ */
        font-style: italic; /* å¯ä»¥ä½¿ç”¨æ–œä½“ */

        /* å…³é”®ï¼šé˜»æ­¢ä¼ªå…ƒç´ æ•è·é¼ æ ‡äº‹ä»¶ï¼Œè¿™æ ·ç”¨æˆ·æ‰èƒ½ç‚¹å‡»å¹¶èšç„¦åˆ°ç©ºçš„ div ä¸Š */
        pointer-events: none;
      }
    </style>
    <!-- å…·ä½“å— -->
    <style>
                /* ================================
                      ç¼–è¾‘å™¨å®¹å™¨
                      ================================ */
                #editor-container {
                  max-width: 980px;
                  margin: 8px auto;
                  background: var(--bg);
                  border-radius: 12px;
                  padding: 8px;
                  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.06);
                }

                #editor {
                  min-height: 300px;
                }

                a {
                  color: var(--hi);
                }

                /* æ ‡é¢˜1 */
                h1,
                h2,
                h3,
                h4,
                h5,
                h6 {
                  display: block;
                  max-width: 980px;
                  margin: 0px auto;
                  background: var(--bg);
                  border-radius: 12px;
                  padding: 8px 80px;
                  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.06);
                }

                /* ================================
                      å—çº§å…ƒç´  (block)
                      ================================ */

                /* æ‰€æœ‰blockå†…è¾¹è·ç»Ÿä¸€,ä¸Šä¸‹å®½åº¦4x */
                .block {
                  position: relative;
                  padding: 4px 0px;
                  display: flex;
                  /* ä¸»è½´è®¾ç½®ä¸ºåˆ— */
                  flex-direction: column;
                  gap: 4px;
                }

                /* .block.dragging {
                  opacity: 0.6;
                  background: #eef6ff;
                } */

                .block[draggable="true"] {
                  -webkit-user-drag: element; /* CSS ç¡®ä¿å®ƒåœ¨ Chrome/Safari ä¸­èƒ½æ­£ç¡®è¢«æ‹–æ‹½ã€‚ */
                }

                /* ================================
                      å—å†…å®¹ + æ‹–æ‹½æ‰‹æŸ„
                      ================================ */

                /* æŠ˜å  (details/summary) */
                details {
                  width: 100%;
                }

                summary {
                  flex: 1;
                  position: block;
                  padding: 4px 0px;
                  display: flex;
                  align-items: flex-start;
                  width: 100%;
                  box-sizing: border-box;
                  gap: 0px;
                  cursor: pointer;
                  outline: none;
                }

                summary::-webkit-details-marker {
                  display: none; /* éšè—é»˜è®¤ä¸‰è§’å›¾æ ‡ */
                }

                summary::before {
                  content: "â–¶";
                  height: 18px;
                  width: 18px;
                  color: var(--hi2);
                  transition: transform 0.12s;
                  align-items: flex-start;
                  opacity: 0.5;
                  border-radius: 5px;
                }

                details[open] > summary::before {
                  transform: rotate(90deg); /* å±•å¼€æ—¶æ—‹è½¬ç®­å¤´ */
                }
                .block-content-wrapper {
                  position: absolute;
                  left: 0px;
                  display: flex;
                  gap: 4px;
                  width: 100%;
                  /* ä»å¤´å¼€å§‹ */
                  align-items: flex-start;
                  position: relative;
                }

                .block > .block-content-wrapper {
                  padding: 0 0 0 20px;
                }
                /* æ‹–æ‹½æŠŠæ‰‹ */
                .drag-handle {
                  align-self: flex-start;
                  width: 20px;
                  height: 20px;
                  display: flex;
                  /* ä¸»è½´å’Œäº¤å‰è½´éƒ½ä¸ºä¸­å¿ƒ */
                  align-items: center;
                  justify-content: center;
                  color: var(--hi2);
                  cursor: grab;
                  opacity: 0;
                  transition: opacity 0.2s;
                }

                .block-content-wrapper:hover .drag-handle {
                  opacity: 1; /* hover æ—¶æ˜¾ç¤ºæ‹–æ‹½æ‰‹æŸ„ */
                }

                .drag-handle:active {
                  cursor: grabbing;
                }

                /* æ ‡é¢˜åºå· */
                .heading-number {
                  color: var(--hi2);
                  align-self: flex-start;
                }
                /* å†…å®¹ */
                .content {
                  flex: 1;
                  min-height: 18px;
                  width: auto;
                  padding: 0px;
                  border-radius: 4px;
                  outline: none;
                  box-sizing: border-box;
                  margin: 0;
                }
                /* åˆ é™¤æŒ‰é’® */
                .delete-btn {
                  order: 999;
                  border: 0px;
                  border-radius:10px;
                  width: 20px;
                  height: 20px;
                  font-size:20px;
                  background: var(--bg);
                  margin-left: auto; /* æŠŠå®ƒæ¨åˆ°æœ€å³è¾¹ */
                  margin-right: 10px; /* æŠŠå®ƒæ¨åˆ°æœ€å³è¾¹ */
                  display: flex; /* è®©æŒ‰é’®é‡Œçš„å†…å®¹å±…ä¸­ */
                  align-items: center;
                  justify-content: center;
                  color: var(--hi2);
                  cursor: pointer;
                  opacity: 0;
                  transition: opacity 0.2s;
                }
                .block[data-type="li"] > .block-content-wrapper > .delete-btn,
                .block[data-type="taskitem"] > .block-content-wrapper > .delete-btn {
                  border-radius: 50%;
                  background: var(--hi2);
                  color: var(--hi2);
                  width: 15px;
                  height: 15px;
                }
                .block-content-wrapper:hover .delete-btn {
                  opacity: 1; /* hover æ—¶æ˜¾ç¤ºæ‹–æ‹½æ‰‹æŸ„ */
                }

                /* ================================
                      ç©ºå®¹å™¨å¯æ‹–æ‹½æç¤º (Fix for dropping)
                      ================================ */
                .block-children:empty {
                  min-height: 20px; /* ğŸš©ç»™ç©ºå®¹å™¨ä¸€ä¸ªé«˜åº¦ï¼Œæ‰èƒ½ä½œä¸ºæœ‰æ•ˆçš„ drop ç›®æ ‡ */
                  padding: 4px 0;
                  transition: background-color 0.2s ease;
                }

                /* ç©ºå®¹å™¨ hover æ—¶æ˜¾ç¤ºè“è‰²èƒŒæ™¯ */
                .block:hover > details > .block-children:empty,
                .block:hover > .block-children:empty {
                  background: #eef6ff;
                  border-radius: 4px;
                }

                /* ================================
                      åˆ—è¡¨å— (UL / OL / Task)
                      ================================ */
                /* æŠ˜å å›¾æ ‡ */
             	div[data-type="ul"],
            	div[data-type="ol"],
            	div[data-type="task"]{
            border-radius: 10px;
            	background: rgba(168, 174, 190, 0.459);
            		}
                div[data-type="ul"] > details > summary::before,
                div[data-type="ol"] > details > summary::before,
                div[data-type="task"] > details > summary::before,
                div[data-type="pre"] > details > summary::before {
                  content: "ğŸŸ "; /* æˆ–è€…ç©ºå­—ç¬¦ä¸² "" ä¹Ÿè¡Œ */
                  margin:0 10px;
                  color: var(--hi2);
                  transition: transform 0.3s ease;
                  opacity: 1;
                }
                div[data-type="ul"] > details[open] > summary::before,
                div[data-type="ol"] > details[open] > summary::before,
                div[data-type="task"] > details[open] > summary::before,
                div[data-type="pre"] > details[open] > summary::before {
                  content: "ğŸŸ§"; /* æˆ–è€…ç©ºå­—ç¬¦ä¸² "" ä¹Ÿè¡Œ */
                  transform: rotate(360deg); /* å±•å¼€æ—¶æ—‹è½¬ç®­å¤´ */
                  transform-origin: center center; /* é»˜è®¤ï¼Œç»•ä¸­å¿ƒæ—‹è½¬ */
                }

                div[data-type="ul"] > details > summary,
                div[data-type="ol"] > details > summary,
                div[data-type="task"] > details > summary,
                div[data-type="pre"] > details > summary {
                  /* margin-left: 10px; /* æŠŠå®ƒæ¨åˆ°æœ€å³è¾¹ */ */
                  color: var(--hi2);
                  opacity: 1;
                  border-radius:10px;
                }
                /* åŒºåˆ†é¢œè‰² */
                div[data-type="ul"] > details > summary{background:var(--hi1);}
                div[data-type="ol"] > details > summary{background:var(--hi1);}
                div[data-type="task"] > details > summary{background:var(--hi);}
                div[data-type="pre"] > details > summary{background:var(--hi2);}
      		  div[data-type="ul"] > details > summary::before {
          content: "ğŸ“‘";
          display: inline-block;
          background: var(--hi1);
          padding: 2px 4px;
          background: transparent;

      }
      div[data-type="ol"] > details > summary::before {
          content: "ğŸ”¢";
          display: inline-block;
          background: transparent;

      }
      div[data-type="task"] > details > summary::before {
          content: "âœ…";
          display: inline-block;
          background: transparent;

      }
      div[data-type="pre"] > details > summary::before {
          content: "ğŸ’»";
          display: inline-block;
          background: transparent;

      }

                /* #heading-7-1755659624403 > details > div > div:nth-child(1) > details > summary */

                .block.list-block-ul .drag-handle::before,
                .block.list-block-ol .drag-handle::before,
                .block.list-block-task .drag-handle::before {
                  font-size: 20px;
                  font-weight: bold;
                }

                .block.list-block-ul .drag-handle {
                  font-size: 14px;
                }

                .block.list-block-ul .drag-handle::before {
                  content: "â—";
                  color: #666;
                }

                /* éšè— drag-handle çš„é»˜è®¤é¢œè‰² */
                .block.list-block-ul .drag-handle,
                .block.list-block-ol .drag-handle,
                .block.list-block-task .drag-handle {
                  color: transparent;
                }

                /* å­å—å®¹å™¨ */
                .block-children {
                  margin-left: 0px;
                  padding-left: 0px;
                  border-left: 0px solid #f0f0f0;
                }

                /* åˆ—è¡¨å†…åµŒæ ·å¼ */
                ul.block-children,
                ol.block-children {
                  margin: 0;
                  padding-left: 28px;
                }

                ul.block-children li.block,
                ol.block-children li.block {
                  margin: 4px 0;
                }

                li.block {
                  list-style: inherit;
                }

                /* ================================
                      ä»»åŠ¡åˆ—è¡¨ (checkbox)
                      ================================ */
                .task-checkbox {
                  margin-right: 8px;
                  transform: translateY(2px);
                }

                /* ================================
                      è¡¨æ ¼ (table)
                      ================================ */
                .table-block table {
                  width: 100%;
                  border-collapse: collapse;
                  margin: 8px 0;
                }

                .table-block th,
                .table-block td {
                  border: 1px solid #eaeaea;
                  padding: 8px;
                  min-width: 100px;
                }

                .table-controls {
                  margin-top: 6px;
                  display: flex;
                  gap: 8px;
                }

                /* ================================
                      ä»£ç å— (pre + toolbar)
                      ================================ */
                .pre-block pre {
                  background: #1e1e2d;
                  color: #e6e6e6;
                  padding: 12px;
                  border-radius: 6px;
                  overflow: auto;
                  font-family: "Fira Code", monospace;
                  font-size: 0.9rem;
                }

                .code-toolbar {
                  flex: 1;
                  margin-left: auto;
                  display: flex;
                  gap: 8px;
                  align-items: center;
                  justify-content: flex-end;
                  opacity: 0;
                  transition: opacity 0.12s;
                }

                .block:hover .code-toolbar {
                  opacity: 1; /* hover æ—¶æ˜¾ç¤ºä»£ç å·¥å…·æ  */
                }

                /* ================================
                      å›¾ç‰‡å—
                      ================================ */
                img {
                  max-width: 100%;
                  border-radius: 6px;
                  margin-top: 6px;
                }
    </style>
    <!-- å·¥å…·æ æ ·å¼ -->
    <style>
      /* ================================
      æ·»åŠ èœå• (æµ®åŠ¨å¼¹å‡º)
      ================================ */
      .add-menu {
        position: fixed;
        background: #fff;
        border: 1px solid var(--text2);
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        padding: 6px;
        z-index: 1200;
        width: 220px;
      }

      .add-menu button {
        display: block;
        width: 100%;
        text-align: left;
        padding: 8px;
        border-radius: 6px;
        border: none;
        background: none;
        cursor: pointer;
      }

      .add-menu button:hover {
        background: #f5f7fb;
      }

      /* æ‹–æ‹½ä½ç½®æŒ‡ç¤ºçº¿ */
      .drop-indicator {
        height: 3px;
        background: var(--hi1);
        margin: -2px 0;
        border-radius: 3px;
      }

      /* ================================
      æµ®åŠ¨å·¥å…·æ  (æ–‡å­—å·¥å…·ç­‰)
      ================================ */
      #floating-toolbar {
        position: absolute;
        display: none;
        background: #222;
        color: #fff;
        padding: 6px;
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
        z-index: 1300;
        display: flex;
        gap: 6px;
        align-items: center;
      }

      #floating-toolbar button {
        background: none;
        border: none;
        color: #fff;
        padding: 6px 8px;
        cursor: pointer;
        border-radius: 6px;
        position: relative;
      }

      /* é¢œè‰²é€‰æ‹©å™¨ */
      #color-palette {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        border-radius: 6px;
        padding: 8px;
        display: none; /* é»˜è®¤éšè— */
        /* æ¯åˆ—å¤šå°‘ä¸ª */
        grid-template-columns: repeat(9, 1fr);
        gap: 6px;
        margin-bottom: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      #color-palette.visible {
        display: grid;
      }

      .color-swatch {
        width: 24px;
        height: 24px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.1s;
      }

      .color-swatch:hover {
        transform: scale(1.1);
        border-color: #fff;
      }

      /* ================================
      FAB (æµ®åŠ¨æ“ä½œæŒ‰é’®)
      ================================ */
      #fab-container {
        position: fixed;
        right: 18px;
        bottom: 18px;
        z-index: 2000;
        display: flex;
        flex-direction: column-reverse;
        align-items: flex-end;
        gap: 12px;
      }

      #fab {
        position: relative;
        right: auto;
        bottom: auto;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 8px;
      }

      #fab-main {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: var(--hi1);
        color: var(--text);
        border: none;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        font-size: 24px;
      }

      .fab-item {
        width: 100px;
        margin: 4px 0;
        padding: 8px 12px;
        border-radius: 8px;
        background: var(--hi1);
        color: var(--text);
        border: 1px solid var(--hi);
        cursor: pointer;
      }

      .fab-item:hover {
        background: var(--hi2);
      }

      /* ================================
      TOC (ç›®å½•æµ®åŠ¨æŒ‰é’®)
      ================================ */
      #toc-fab {
        position: relative;
      }

      #toc-button {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: var(--hi1);
        color: var(--text);
        border: none;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #toc-panel {
        position: absolute;
        bottom: 0;
        right: 64px;
        width: 280px;
        max-height: 400px;
        overflow-y: auto;
        background: var(--hi);
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        padding: 8px;
        opacity: 0;
        visibility: hidden;
        transform: translateX(10px);
        transition: opacity 0.2s, visibility 0.2s, transform 0.2s;
        pointer-events: none; /* é»˜è®¤ä¸å¯äº¤äº’ */
      }

      #toc-panel.is-visible {
        opacity: 1;
        visibility: visible;
        transform: translateX(0);
        pointer-events: auto; /* æ˜¾ç¤ºæ—¶å¯äº¤äº’ */
      }

      #toc-panel ul {
        list-style: none;
        padding-left: 0;
        margin: 0;
      }

      #toc-panel li a {
        display: block;
        padding: 6px 10px;
        text-decoration: none;
        color: var(--text);
        border-radius: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #toc-panel li a:hover {
        background: var(--hi1);
      }

      #toc-panel .toc-level-1 {
        padding-left: 0px;
      }
      #toc-panel .toc-level-2 {
        padding-left: 15px;
      }
      #toc-panel .toc-level-3 {
        padding-left: 30px;
      }
      #toc-panel .toc-level-4 {
        padding-left: 45px;
      }
      #toc-panel .toc-level-5 {
        padding-left: 60px;
      }
      #toc-panel .toc-level-6 {
        padding-left: 75px;
      }
    </style>
  </head>
  <body>
    <h1 contenteditable="true">ğŸ¤ªJI_tionğŸ¤ª</h1>
    <div id="editor-container">
      <div id="editor"></div>
    </div>
    <!-- ğŸ’¡ğŸ’¡ğŸ’¡ğŸ’¡ğŸ’¡å·¥å…·æ ğŸ’¡ğŸ’¡ğŸ’¡ğŸ’¡ğŸ’¡ -->
    <!-- ğŸ¨å­—ä½“æ ·å¼çª—å£ -->
    <div id="floating-toolbar">
      <button id="bold-btn" title="Bold"><b>B</b></button>
      <button id="italic-btn" title="Italic"><i>I</i></button>
      <button id="underline-btn" title="Underline"><u>U</u></button>
      <div
        style="
          width: 1px;
          height: 18px;
          background: rgba(255, 255, 255, 0.12);
          margin: 0 6px;
        "
      ></div>
      <button id="link-btn" title="Link">ğŸ”—</button>
      <button id="color-btn" title="Color">
        ğŸ¨
        <div id="color-palette"></div>
      </button>
      <button id="clear-format-btn" title="Clear">Tx</button>
    </div>
    <!-- ğŸ”¨å³ä¸‹è§’å·¥å…·æ  -->
    <div id="fab-container">
      <div aria-hidden="false" id="fab">
        <button id="fab-main" title="å·¥å…·">+</button>
        <div
          id="fab-menu"
          style="display: none; flex-direction: column; align-items: flex-end"
        >
          <button class="fab-item" id="fab-clear">æ¸…ç©ºæœ¬åœ°</button>
          <button class="fab-item" id="fab-fold">æŠ˜å </button>
          <button class="fab-item" id="fab-import">å¯¼å…¥ MD</button>
          <button class="fab-item" id="fab-export-md">å¯¼å‡º MD</button>
          <button class="fab-item" id="fab-export-pdf">å¯¼å‡º PDF</button>
          <button class="fab-item" id="fab-clean-all">æ¸…ç©ºé¡µé¢</button>
          <button class="fab-item" id="fab-save">ä¿å­˜ç½‘é¡µ</button>
        </div>
      </div>
      <div id="toc-fab">
        <button id="toc-button" title="ç›®å½•">â˜°</button>
        <div id="toc-panel">
          <ul id="toc-list"></ul>
        </div>
      </div>
    </div>
    <!-- å…¨å±€å˜é‡æ„å»º -->
    <script>
      const editor = document.getElementById("editor");
      const editorContainer = document.getElementById("editor-container");
      const floatingToolbar = document.getElementById("floating-toolbar");

      const colorBtn = document.getElementById("color-btn");
      const colorPalette = document.getElementById("color-palette");

      const BLOCK_TYPES = {
        p: { tag: "p", placeholder: "æ®µè½", container: false },
        heading: {
          tag: "h2",
          placeholder: "æ ‡é¢˜ ",
          container: true,
          isToggle: true,
        },
        blockquote: {
          tag: "blockquote",
          placeholder: "å¼•ç”¨",
          container: false,
        },
        ul: {
          tag: "ul",
          placeholder: "æ— åºåˆ—è¡¨",
          container: true,
          isList: true,
          defaultChild: "li",
          isToggle: true,
        },
        ol: {
          tag: "ol",
          placeholder: "æœ‰åºåˆ—è¡¨",
          container: true,
          isList: true,
          defaultChild: "li",
          isToggle: true,
        },
        li: { tag: "li", placeholder: "åˆ—è¡¨é¡¹", container: false },
        task: {
          tag: "ul",
          placeholder: "ä»»åŠ¡åˆ—è¡¨",
          container: true,
          isTask: true,
          defaultChild: "li",
          isToggle: true,
        },
        taskitem: {
          tag: "li",
          placeholder: "ä»»åŠ¡é¡¹",
          container: false,
          isTaskItem: true,
        },
        table: {
          tag: "div",
          isTable: true,
          placeholder: "è¡¨æ ¼",
          container: false,
        },
        pre: {
          tag: "div",
          hasCode: true,
          isToggle: true,
          placeholder: "ä»£ç å— ",
          container: true,
        },
        img: {
          tag: "div",
          isImage: true,
          placeholder: "å›¾ç‰‡",
          container: false,
        },
      };

      const CODE_LANGS = {
        javascript: "JavaScript",
        python: "Python",
        html: "HTML",
        css: "CSS",
        bash: "Bash",
        plaintext: "Plain Text",
      };
      const PALETTE_COLORS = [
        // é»‘ç™½ç°
        "#000000",
        "#222222",
        "#444444",
        "#666666",
        "#888888",
        "#999999",
        "#bbbbbb",
        "#cccccc",
        "#eeeeee",
        "#ffffff",

        // çº¢æ©™é»„
        "#ff4d4f",
        "#ff7875",
        "#ffa39e",
        "#ffc069",
        "#ff9c6e",
        "#faad14",
        "#ffd666",
        "#ffe58f",

        // ç»¿
        "#52c41a",
        "#73d13d",
        "#95de64",
        "#b7eb8f",
        "#d9f7be",

        // è“
        "#1890ff",
        "#40a9ff",
        "#69c0ff",
        "#91d5ff",
        "#bae7ff",

        // ç´«
        "#722ed1",
        "#9254de",
        "#b37feb",
        "#d3adf7",
        "#efdbff",

        // ç²‰
        "#eb2f96",
        "#f759ab",
        "#ff85c0",
        "#ffadd2",
        "#ffd6e7",

        // æ£•/æš–ç°
        "#a0522d",
        "#c08050",
        "#d9a066",
        "#e6c3a0",
        "#f0e0d9",

        // é’ç»¿
        "#13c2c2",
        "#36cfc9",
        "#5cdbd3",
        "#87e8de",
        "#b5f5ec",
      ];

      const cmdMenuState = {
        active: false,
        element: null,
        selectedIndex: 0,
        triggerBlock: null,
        triggerRect: null,
      };

      const HISTORY_LIMIT = 120;
      let history = [],
        historyIndex = -1,
        historyLock = false;
      // ä» URL è·å–æ–‡ä»¶å
      const FILE_NAME = decodeURIComponent(
        location.pathname.split("/").pop() || "document.html"
      );

      // ç”Ÿæˆå®‰å…¨çš„ localStorage key
      const LOCAL_STORAGE_KEY =
        "editorContent_" + FILE_NAME.replace(/[\\\/:*?"<>|]/g, "_");
      // é˜²æ­¢é—ªçƒè·³åŠ¨
      const debounce = (fn, wait = 300) => {
        let t;
        return (...a) => {
          clearTimeout(t);
          t = setTimeout(() => fn(...a), wait);
        };
      };
      function downloadFile(filename, text, mime = "text/plain") {
        // åˆ›å»ºä¸€ä¸ª Blob å¯¹è±¡ï¼Œé‡Œé¢è£…çš„æ˜¯è¦ä¿å­˜çš„æ–‡æœ¬
        const blob = new Blob([text], { type: mime });

        // åˆ›å»ºä¸€ä¸ª <a> æ ‡ç­¾
        const a = document.createElement("a");

        // æŠŠ Blob å¯¹è±¡è½¬æ¢æˆä¸´æ—¶çš„æ–‡ä»¶ URLï¼Œèµ‹å€¼ç»™ <a> çš„ href
        a.href = URL.createObjectURL(blob);

        // è®¾ç½®ä¸‹è½½ä¸‹æ¥çš„æ–‡ä»¶å
        a.download = filename;

        // æ¨¡æ‹Ÿç‚¹å‡» <a>ï¼Œè§¦å‘æµè§ˆå™¨ä¸‹è½½
        a.click();

        // 3 ç§’åé‡Šæ”¾æ‰ä¸´æ—¶çš„ URLï¼Œé¿å…å†…å­˜æ³„æ¼
        setTimeout(() => URL.revokeObjectURL(a.href), 3000);
      }

      async function fileToDataURL(file) {
        return await new Promise((res, rej) => {
          const fr = new FileReader();
          fr.onload = () => res(fr.result);
          fr.onerror = rej;
          fr.readAsDataURL(file);
        });
      }
    </script>
    <!-- æ·»åŠ å— -->
    <script>
      /*
å°† createBlock é‡æ„ä¸ºå¤šä¸ªå°å‡½æ•°ï¼Œä¾¿äºç†è§£ä¸æµ‹è¯•ã€‚
å‡è®¾å…¨å±€å­˜åœ¨ï¼šBLOCK_TYPES, CODE_LANGS, Prism(é«˜äº®), debounce, saveEditorState, updateAllHeadingNumbers
*/

      // --- helpers å·¥å…·å‡½æ•° -----------------------------------------------------
      // åˆ›å»ºæ‹–æ‹½æ‰‹æŸ„
      function createDragHandle() {
        const handle = document.createElement("div");
        handle.className = "drag-handle";
        handle.innerText = "â ¿";
        return handle;
      }

      // åˆ›å»ºåˆ é™¤æŒ‰é’®ï¼ˆå¯ä¼ å…¥æç¤ºæ–‡å­—å’Œç‚¹å‡»å›è°ƒï¼‰
      function createDeleteBtn({ title = "åˆ é™¤æ­¤å—", onClick }) {
        const del = document.createElement("button");
        del.className = "delete-btn";
        del.innerText = "Ã—";
        del.title = title;
        del.addEventListener("click", (e) => {
          e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘çˆ¶èŠ‚ç‚¹ç‚¹å‡»
          if (typeof onClick === "function") onClick();
        });
        return del;
      }

      // åˆ›å»ºé€šç”¨çš„å¯ç¼–è¾‘å†…å®¹å…ƒç´ 
      function makeContentElement(
        tag = "div",
        type = "p",
        html = "",
        placeholder = ""
      ) {
        const el = document.createElement(tag);
        el.className = "content";
        el.setAttribute("contenteditable", "true"); // å¯ç¼–è¾‘
        el.dataset.type = type; // æ•°æ®å±æ€§å­˜å‚¨ç±»å‹
        el.innerHTML = html || "";
        if (placeholder) el.dataset.placeholder = placeholder;
        // è¾“å…¥äº‹ä»¶è§¦å‘ä¿å­˜ï¼ˆé˜²æŠ–å¤„ç†ï¼‰
        el.addEventListener(
          "input",
          debounce(() => saveEditorState(), 300)
        );
        return el;
      }

      // ä¸ºå—ç»‘å®šå¯æ‹–æ‹½åŠŸèƒ½
      function armDraggable(el) {
        const handle = el.querySelector(".drag-handle");
        if (handle) {
          handle.addEventListener(
            "mousedown",
            () => (el.dataset._armed = "true")
          );
          document.addEventListener("mouseup", () => delete el.dataset._armed, {
            capture: true,
          });
        }
      }

      // --- å…·ä½“ç±»å‹çš„ block æ„å»ºå‡½æ•° --------------------------------------------
      // æ®µè½ç±» block
      function block_p(
        type,
        content,
        options,
        def,
        parentForContent,
        parentForChildren
      ) {
        const tag = def.tag || "div";
        const el = makeContentElement(
          tag,
          type,
          options.content || content || "",
          def.placeholder || ""
        );
        parentForContent.appendChild(el);
        return el;
      }

      // é€šç”¨åˆ—è¡¨é¡¹æ„å»ºå‡½æ•°ï¼ˆä¾›æ— åº/æœ‰åº/ä»»åŠ¡åˆ—è¡¨å¤ç”¨ï¼‰
      function _createListItemBase(type, content, options) {
        const li = document.createElement("li");
        li.className = "block";
        li.dataset.type = type;
        li.setAttribute("draggable", "true");

        const wrapper = document.createElement("div");
        wrapper.className = "block-content-wrapper";
        const handle = createDragHandle();
        wrapper.appendChild(handle);

        // ä»»åŠ¡é¡¹å¢åŠ å¤é€‰æ¡†
        if (type === "taskitem") {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "task-checkbox";
          checkbox.checked = options.checked === true;
          wrapper.appendChild(checkbox);
        }
        // æ— åº/æœ‰åºåˆ—è¡¨é¡¹å¢åŠ åœ†ç‚¹
        if (type === "li") {
          const bullet = document.createElement("span");
          bullet.className = "list-bullet";
          bullet.textContent = "â€¢"; // åœ†ç‚¹
          wrapper.appendChild(bullet);
        }

        // åˆ—è¡¨é¡¹çš„å†…å®¹åŒºåŸŸ
        const contentEl = document.createElement("div");
        contentEl.className = "content";
        contentEl.setAttribute("contenteditable", "true");
        contentEl.dataset.type = type;
        contentEl.innerHTML = options.content || content || "";
        contentEl.dataset.placeholder =
          (BLOCK_TYPES[type] && BLOCK_TYPES[type].placeholder) || "";

        wrapper.appendChild(contentEl);
        li.appendChild(wrapper);

        // åˆ é™¤æŒ‰é’®
        const del = createDeleteBtn({
          title: "åˆ é™¤æ­¤é¡¹",
          onClick: () => {
            li.remove();
            saveEditorState();
          },
        });
        wrapper.appendChild(del);

        // è¾“å…¥äº‹ä»¶ä¿å­˜
        contentEl.addEventListener(
          "input",
          debounce(() => saveEditorState(), 300)
        );
        // æ‹–æ‹½å¤„ç†
        handle.addEventListener(
          "mousedown",
          () => (li.dataset._armed = "true")
        );
        document.addEventListener("mouseup", () => delete li.dataset._armed, {
          capture: true,
        });

        return li;
      }

      // ä¸‰ç§åˆ—è¡¨ç±»å‹éƒ½å¤ç”¨ _createListItemBase
      function block_list_task(type, content, options) {
        return _createListItemBase(type, content, options);
      }
      function block_list_ul(type, content, options) {
        return _createListItemBase(type, content, options);
      }
      function block_list_ol(type, content, options) {
        return _createListItemBase(type, content, options);
      }

      // å¼•ç”¨å—
      function block_blockquote(type, content, options, def, parentForContent) {
        const tag = def.tag || "blockquote";
        const el = makeContentElement(
          tag,
          type,
          options.content || content || "",
          def.placeholder || ""
        );
        parentForContent.appendChild(el);
        return el;
      }

      // å›¾ç‰‡å—
      function block_img(type, content, options, parentForContent) {
        const imgWrap = document.createElement("div");
        imgWrap.className = "img-block";
        const img = document.createElement("img");
        img.src =
          options.src ||
          content ||
          "https://via.placeholder.com/600x120.png?text=Image";
        img.alt = options.alt || "image";
        imgWrap.appendChild(img);
        parentForContent.appendChild(imgWrap);
        return imgWrap;
      }

      // æ ‡é¢˜å—
      function block_heading(type, content, options, parentForContent) {
        const level = options.level || 2;
        const tag = `h${level}`;
        const el = makeContentElement(
          tag,
          type,
          options.content || content || "",
          (BLOCK_TYPES[type] && BLOCK_TYPES[type].placeholder) || ""
        );
        el.dataset.level = level;

        const num = document.createElement("span");
        num.className = "heading-number";
        parentForContent.insertBefore(
          num,
          parentForContent.querySelector(".drag-handle").nextSibling
        );
        parentForContent.appendChild(el);
        return el;
      }

      // ä»£ç å—
      function block_pre(
        type,
        content,
        options,
        parentForChildren,
        parentForContent,
        summary
      ) {
        const pre = document.createElement("pre");
        const code = document.createElement("code");
        const lang = options.lang || "javascript";
        code.className = "language-" + lang;
        code.setAttribute("contenteditable", "true");
        code.textContent = options.content || content || "1111";
        pre.appendChild(code);

        // å·¥å…·æ ï¼ˆè¯­è¨€é€‰æ‹©ã€å¤åˆ¶æŒ‰é’®ï¼‰
        const toolbar = document.createElement("div");
        toolbar.className = "code-toolbar";
        const sel = document.createElement("select");
        for (const k in CODE_LANGS) sel.add(new Option(CODE_LANGS[k], k));
        sel.value = lang;
        sel.addEventListener("change", () => {
          code.className = "language-" + sel.value;
          if (parentForChildren && parentForChildren.dataset)
            parentForChildren.dataset.lang = sel.value;
          Prism.highlightElement(code);
          saveEditorState();
        });
        const copyBtn = document.createElement("button");
        copyBtn.textContent = "Copy";
        copyBtn.addEventListener("click", () => {
          navigator.clipboard.writeText(code.textContent);
          copyBtn.textContent = "Copied";
          setTimeout(() => (copyBtn.textContent = "Copy"), 1200);
        });
        toolbar.appendChild(sel);
        toolbar.appendChild(copyBtn);

        // å·¥å…·æ æ’å…¥ä½ç½®ï¼štoggle å—æ—¶æ”¾åˆ° summaryï¼Œå¦åˆ™æ”¾åˆ° parentForContent
        if (summary) summary.appendChild(toolbar);
        else if (parentForContent) parentForContent.appendChild(toolbar);

        if (parentForChildren) parentForChildren.appendChild(pre);
        if (parentForChildren && parentForChildren.dataset)
          parentForChildren.dataset.lang = lang;

        // è¾“å…¥äº‹ä»¶æ—¶é«˜äº®+ä¿å­˜
        code.addEventListener(
          "input",
          debounce(() => {
            Prism.highlightElement(code);
            saveEditorState();
          }, 300)
        );

        return pre;
      }

      // è¡¨æ ¼å—
      function block_table(type, content, options, block) {
        const tbWrap = document.createElement("div");
        tbWrap.className = "table-block";
        const table = document.createElement("table");
        table.innerHTML =
          options.tableContent ||
          `<thead><tr><th contenteditable="true"></th></tr></thead><tbody><tr><td contenteditable="true"></td></tr></tbody>`;
        tbWrap.appendChild(table);
        block.appendChild(tbWrap);
        const controls = document.createElement("div");
        controls.className = "table-controls";
        controls.innerHTML = `<button class="add-row">æ·»åŠ è¡Œ</button><button class="add-col">æ·»åŠ åˆ—</button><button class="del-row">åˆ é™¤è¡Œ</button><button class="del-col">åˆ é™¤åˆ—</button>`;
        block.appendChild(controls);
        return tbWrap;
      }

      // --- ä¸»å·¥å‚å‡½æ•° ----------------------------------------------------------
      function createBlock(type = "p", content = "", options = {}) {
        const def = BLOCK_TYPES[type];
        if (!def) return null; // æœªå®šä¹‰çš„ç±»å‹ç›´æ¥è¿”å› null

        // åˆ—è¡¨é¡¹ï¼ˆli æˆ– taskitemï¼‰å•ç‹¬è¿”å› <li>
        if (type === "li" || type === "taskitem") {
          return _createListItemBase(type, content, options);
        }

        const block = document.createElement("div");
        block.className = "block";
        block.dataset.type = type;
        block.setAttribute("draggable", "true");

        // æ ¹æ®ç±»å‹æ·»åŠ æ ·å¼æ ‡è®°
        if (def.isList && type === "ul") block.classList.add("list-block-ul");
        if (def.isList && type === "ol") block.classList.add("list-block-ol");
        if (def.isTask && type === "task")
          block.classList.add("list-block-task");

        const wrapper = document.createElement("div");
        wrapper.className = "block-content-wrapper";
        const handle = createDragHandle();

        let details, summary, parentForContent, parentForChildren;
        const isToggle = !!def.isToggle;

        // toggle å—ä½¿ç”¨ <details>/<summary> åŒ…è£¹
        if (isToggle) {
          block.classList.add("details-block");
          details = document.createElement("details");
          details.open = options.openState !== false;
          summary = document.createElement("summary");

          wrapper.appendChild(handle);
          summary.appendChild(wrapper);
          details.appendChild(summary);
          block.appendChild(details);

          parentForContent = wrapper;
          parentForChildren = details;
        } else {
          wrapper.appendChild(handle);
          block.appendChild(wrapper);
          parentForContent = wrapper;
          parentForChildren = block;
        }

        // åˆ é™¤æŒ‰é’®ï¼ˆåˆ é™¤æ—¶æ›´æ–°æ ‡é¢˜åºå·å¹¶ä¿å­˜ï¼‰
        const del = createDeleteBtn({
          title: "åˆ é™¤æ­¤å—",
          onClick: () => {
            block.remove();
            updateAllHeadingNumbers();
            saveEditorState();
          },
        });

        // æ ¹æ®ä¸åŒç±»å‹è°ƒç”¨å…·ä½“æ„å»ºå‡½æ•°
        if (def.hasCode) {
          block.classList.add("pre-block");
          block_pre(
            type,
            content,
            options,
            parentForChildren,
            parentForContent,
            summary
          );
        } else if (def.isImage) {
          block_img(type, content, options, parentForContent);
        } else if (def.isTable) {
          block_table(type, content, options, block);
        } else if (!def.isList && !def.isTask) {
          if (type === "heading") {
            block_heading(type, content, options, parentForContent);
          } else if (type === "blockquote") {
            block_blockquote(type, content, options, def, parentForContent);
          } else {
            block_p(
              type,
              content,
              options,
              def,
              parentForContent,
              parentForChildren
            );
          }
        }

        // å®¹å™¨ç±» blockï¼ˆå¯åŒ…å«å­å—ï¼‰
        if (def.container) {
          let containerEl;
          if (def.isList || def.isTask)
            containerEl = document.createElement(def.tag);
          else containerEl = document.createElement("div");
          containerEl.className = "block-children";
          parentForChildren.appendChild(containerEl);

          // é€’å½’åˆ›å»ºå­å—
          if (Array.isArray(options.children)) {
            options.children.forEach((ch) => {
              const childNode = createBlock(ch.type, ch.content || "", ch);
              if (childNode) containerEl.appendChild(childNode);
            });
          }
        }

        wrapper.appendChild(del);
        armDraggable(block);

        return block;
      }

      // å°†éƒ¨åˆ†æ–¹æ³•æš´éœ²åˆ°å…¨å±€ï¼ˆä¾¿äºå¤–éƒ¨è°ƒç”¨ï¼‰
      window.EditorBlockFactory = {
        createBlock,
        createDragHandle,
        createDeleteBtn,
        block_p,
        block_list_task,
        block_list_ul,
        block_list_ol,
        block_blockquote,
        block_img,
        block_heading,
        block_pre,
        block_table,
      };

      /*
è¯´æ˜ï¼š
- æ­¤é‡æ„ä¿æŒäº†åŸæœ‰ DOM ç»“æ„å’Œäº‹ä»¶ç»‘å®šï¼Œä½†å°†èŒè´£æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•°ã€‚
- ä¸€äº›å…¨å±€ä¾èµ–ï¼ˆBLOCK_TYPES, CODE_LANGS, Prism, debounce, saveEditorState, updateAllHeadingNumbersï¼‰éœ€è¦å¤–éƒ¨æä¾›ã€‚
- å¯ä»¥è¿›ä¸€æ­¥æ‹†åˆ†ä¸º ES æ¨¡å—ï¼Œæˆ–å¢åŠ  TypeScript ç±»å‹ã€Jest å•å…ƒæµ‹è¯•ã€‚
*/
    </script>
    <!-- æ·»åŠ å¿«-èœå• -->
    <script>
      function createAddMenu(
        parentContainer,
        beforeElement = null,
        isCmd = false,
        e = null
      ) {
        closeAllMenus();
        const menu = document.createElement("div");
        menu.className = "add-menu";
        const types = [
          "p",
          "heading",
          "blockquote",
          "ul",
          "ol",
          "task",
          "table",
          "pre",
          "img",
        ];
        types.forEach((t) => {
          const btn = document.createElement("button");
          btn.textContent = BLOCK_TYPES[t].placeholder || t;
          btn.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            let nb = createBlock(
              t,
              "",
              t === "img"
                ? { src: "https://via.placeholder.com/600x120.png" }
                : {}
            );

            if (BLOCK_TYPES[t].isList || BLOCK_TYPES[t].isTask) {
              const firstItem = createBlock(BLOCK_TYPES[t].defaultChild, "");
              nb.querySelector(".block-children").appendChild(firstItem);
            }

            if (isCmd && cmdMenuState.triggerBlock) {
              cmdMenuState.triggerBlock.insertAdjacentElement("afterend", nb);
            } else {
              parentContainer.insertBefore(nb, beforeElement);
            }

            if (t === "img") {
              const url = prompt(
                "å›¾ç‰‡ URLï¼ˆç•™ç©ºå–æ¶ˆï¼‰",
                "https://via.placeholder.com/600x120.png"
              );
              if (url) {
                nb.querySelector("img").src = url;
              } else {
                nb.remove();
                menu.remove();
                closeAllMenus();
                return;
              }
            }

            setTimeout(() => {
              const focusTarget = nb.querySelector(".content, code, td, img");
              if (focusTarget && focusTarget.focus) focusTarget.focus();
            }, 20);

            updateAllHeadingNumbers();
            saveEditorState();
            menu.remove();
            closeAllMenus();
          });
          menu.appendChild(btn);
        });
        menu.addEventListener("mousedown", (e) => e.stopPropagation());
        menu.addEventListener("click", (e) => e.stopPropagation());
        document.body.appendChild(menu);

        if (isCmd && cmdMenuState.triggerRect) {
          menu.style.left = `${cmdMenuState.triggerRect.left}px`;
          menu.style.top = `${cmdMenuState.triggerRect.bottom + 6}px`;
          cmdMenuState.active = true;
          cmdMenuState.element = menu;
          cmdMenuState.selectedIndex = 0;
          updateCmdMenuSelection();
        } else if (e) {
          menu.style.left = `${e.clientX + 4}px`;
          menu.style.top = `${e.clientY + 4}px`;
        } else {
          const rect = beforeElement
            ? beforeElement.getBoundingClientRect()
            : parentContainer.getBoundingClientRect();
          const topPos = beforeElement ? rect.top : rect.bottom;
          menu.style.left = `${rect.left + 12}px`;
          menu.style.top = `${topPos}px`;
        }
        return menu;
      }

      function closeAllMenus() {
        document.querySelectorAll(".add-menu").forEach((m) => m.remove());
        if (cmdMenuState.active) {
          cmdMenuState.active = false;
          cmdMenuState.element = null;
          cmdMenuState.triggerBlock = null;
          cmdMenuState.triggerRect = null;
          cmdMenuState.selectedIndex = 0;
        }
      }
      function updateCmdMenuSelection() {
        if (!cmdMenuState.active || !cmdMenuState.element) return;
        const opts = cmdMenuState.element.querySelectorAll("button");
        opts.forEach(
          (o, i) =>
            (o.style.background =
              i === cmdMenuState.selectedIndex ? "#eef" : "")
        );
      }
    </script>
    <!-- æ‹–æ‹½å—åŠŸèƒ½ -->
    <script>
      //æ‹–æ‹½åŠŸèƒ½
      // å…¨å±€å˜é‡
      // ç”¨äºå­˜å‚¨å½“å‰æ­£åœ¨æ‹–åŠ¨çš„å—å…ƒç´ ï¼ˆ.blockï¼‰ã€‚
      // æ‹–åŠ¨å¼€å§‹æ—¶èµ‹å€¼ï¼Œæ‹–åŠ¨ç»“æŸåæ¸…ç©ºã€‚
      let draggedItem = null;
      // æ‹–æ‹½å¼€å§‹
      // e.target.closest(".block")ï¼šæ‰¾åˆ°è§¦å‘æ‹–åŠ¨äº‹ä»¶çš„ .block çˆ¶å…ƒç´ ã€‚
      // æ¡ä»¶ dataset._armed === "true"ï¼šæ‰èƒ½è¢«æ‹–åŠ¨ï¼ˆé˜²æ­¢è¯¯æ‹–ï¼‰ã€‚
      // draggedItem = targetBlockï¼šè®°å½•æ‹–åŠ¨çš„å…ƒç´ ã€‚
      // setTimeout(function, delay);setTimeoutå¼‚æ­¥æ‰§è¡Œçš„å‡½æ•°,classæ·»åŠ dragging,0ç§’åæ‰§è¡Œ
      // é¿å…é˜»å¡æ‹–åŠ¨äº‹ä»¶è§¦å‘ã€‚
      // å¦‚æœå…ƒç´ çˆ¶çº§æ²¡æœ‰blockï¼Œè°ƒç”¨ e.preventDefault() é˜»æ­¢æ‹–åŠ¨ã€‚
      editor.addEventListener("dragstart", (e) => {
        const targetBlock = e.target.closest(".block");
        if (targetBlock && targetBlock.dataset._armed === "true") {
          draggedItem = targetBlock;
          setTimeout(() => draggedItem.classList.add("dragging"), 0);
        } else {
          if (targetBlock) e.preventDefault();
        }
      });
      // æ‹–åŠ¨ç»“æŸï¼šdragend
      // ç§»é™¤ dragging æ ·å¼
      // æ¸…ç©º draggedItem
      // åˆ é™¤é¡µé¢ä¸­æ‰€æœ‰çš„ä¸´æ—¶ drop-indicatorï¼ˆæ‹–æ”¾æŒ‡ç¤ºçº¿ï¼‰
      // ä¿å­˜ç¼–è¾‘å™¨çŠ¶æ€ saveEditorState()
      // æ›´æ–°æ ‡é¢˜ç¼–å· updateAllHeadingNumbers()
      editor.addEventListener("dragend", () => {
        if (draggedItem) {
          draggedItem.classList.remove("dragging");
          draggedItem = null;
          document
            .querySelectorAll(".drop-indicator")
            .forEach((i) => i.remove());
          saveEditorState();
          updateAllHeadingNumbers();
        }
      });
      // dragover(æ‹–åŠ¨ä¸­) ï¼Œæµè§ˆå™¨é»˜è®¤ä¸å…è®¸ dropï¼Œè¦ e.preventDefault()
      // åˆ é™¤å·²æœ‰çš„ drop-indicator
      // dropZoneï¼šå½“å‰é¼ æ ‡æ‰€åœ¨å¯æ”¾ç½®åŒºåŸŸï¼ˆ.block-children æˆ– #editorï¼‰
      editor.addEventListener("dragover", (e) => {
        e.preventDefault(); //å…è®¸ drop
        document.querySelectorAll(".drop-indicator").forEach((i) => i.remove());
        // åˆ¤æ–­æ‹–æ”¾æ˜¯å¦åˆæ³•ï¼š
        const dropZone = e.target.closest(".block-children, #editor");
        if (!dropZone || !draggedItem || draggedItem.contains(dropZone)) return;
        //è®¾ç½®ç‰¹æ®Šæ‹–æ‹½åŒºåŸŸ,ulå’Œolåˆ—è¡¨é¡¹
        //å¦‚æœæ˜¯åˆ—è¡¨é¡¹åŒºåŸŸ,ä½†ä¸æ˜¯åˆ—è¡¨å…ƒç´ ,ç›´æ¥è¿”å›
        //å¦‚æœä¸æ˜¯åˆ—è¡¨åŒºåŸŸ,æ˜¯åˆ—è¡¨é¡¹,ä½†ä¸æ˜¯editorç›´æ¥è¿”å›
        const isListDropZone =
          dropZone.tagName === "UL" || dropZone.tagName === "OL";
        const isListItem =
          draggedItem.dataset.type === "li" ||
          draggedItem.dataset.type === "taskitem";
        if (isListDropZone && !isListItem) return;
        if (!isListDropZone && isListItem && dropZone.id !== "editor") return;
        // getDragAfterElement() è®¡ç®—é¼ æ ‡ä½ç½®åº”è¯¥æ’å…¥çš„ä½ç½®
        const after = getDragAfterElement(dropZone, e.clientY);
        if (dropZone.children.length === 0 || after == null) {
          dropZone.appendChild(draggedItem);
        } else {
          dropZone.insertBefore(draggedItem, after);
        }
        const ind = document.createElement("div");
        // åˆ›å»ºä¸€ä¸ª drop-indicatorï¼ˆæç¤ºçº¿ï¼‰æ˜¾ç¤ºæ‹–æ”¾ä½ç½®
        ind.className = "drop-indicator";
        if (after == null) dropZone.appendChild(ind);
        else dropZone.insertBefore(ind, after);
      });
      // dropæ”¾ä¸‹å…ƒç´ 
      // å¦‚æœæ‹–å…¥çš„æ˜¯ å›¾ç‰‡æ–‡ä»¶ï¼š
      // ç”¨ fileToDataURL() è½¬æˆ Base64
      // åˆ›å»ºä¸€ä¸ªæ–°çš„ img block
      // æ’å…¥åˆ° dropZone ä¸­å¯¹åº”ä½ç½®
      // å¦åˆ™æ‹–åŠ¨ å·²æœ‰å—
      // åŒæ ·ç”¨ getDragAfterElement() ç¡®å®šä½ç½®æ’å…¥
      // æ›´æ–°æ ‡é¢˜ç¼–å·å¹¶ä¿å­˜çŠ¶æ€
      editor.addEventListener("drop", async (e) => {
        if (
          // æ–‡ä»¶æ‹–å…¥å›¾ç‰‡å¤„ç†
          e.dataTransfer &&
          e.dataTransfer.files &&
          e.dataTransfer.files.length
        ) {
          const files = Array.from(e.dataTransfer.files);
          const images = files.filter(
            (f) => f.type && f.type.startsWith("image/")
          );
          if (images.length) {
            e.preventDefault();
            const dropZone = e.target.closest(".block-children, #editor");
            const after = getDragAfterElement(dropZone, e.clientY);
            for (const imgFile of images) {
              const dataUrl = await fileToDataURL(imgFile);
              const imgBlock = createBlock("img", "", { src: dataUrl });
              if (after == null) dropZone.appendChild(imgBlock);
              else dropZone.insertBefore(imgBlock, after);
            }
            saveEditorState();
            return;
          }
        }
        // æ™®é€šæ‹–æ”¾å—é€»è¾‘
        e.preventDefault();
        document.querySelectorAll(".drop-indicator").forEach((i) => i.remove());
        const dropZone = e.target.closest(".block-children, #editor");
        if (!dropZone || !draggedItem || draggedItem.contains(dropZone)) return;
        const isListDropZone =
          dropZone.tagName === "UL" || dropZone.tagName === "OL";
        const isListItem =
          draggedItem.dataset.type === "li" ||
          draggedItem.dataset.type === "taskitem";
        if (isListDropZone && !isListItem) return;
        if (!isListDropZone && isListItem && dropZone.id !== "editor") return;
        const after = getDragAfterElement(dropZone, e.clientY);
        if (after == null) dropZone.appendChild(draggedItem);
        else dropZone.insertBefore(draggedItem, after);
        updateAllHeadingNumbers();
        saveEditorState();
      });
      // ä½œç”¨ï¼šæ ¹æ®é¼ æ ‡ y åæ ‡ï¼Œæ‰¾å‡ºæ‹–åŠ¨æ—¶åº”è¯¥æ’å…¥åœ¨ å“ªä¸ªå…ƒç´ å‰é¢
      //containerï¼šæ‹–åŠ¨åŒºåŸŸçš„å®¹å™¨,yä¸ºé¼ æ ‡å‚ç›´ä½ç½®
      // æ’é™¤å½“å‰æ­£åœ¨æ‹–åŠ¨çš„å…ƒç´ ï¼ˆdraggingï¼‰
      // ç”¨ reduce æ‰¾å‡ºè·ç¦»é¼ æ ‡æœ€è¿‘çš„å…ƒç´ 
      function getDragAfterElement(container, y) {
        const children = [
          //æ‰¾åˆ°containerå†…æ‰€æœ‰block,[]è½¬æ¢ä¸ºåˆ—è¡¨
          ...container.querySelectorAll(":scope > .block, :scope > li.block"),
        ].filter((el) => !el.classList.contains("dragging"));
        //æ’é™¤classä¸­æœ‰draggingçš„(å½“å‰æ‹–æ‹½å…ƒç´ )
        return children.reduce(
          (closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset)
              return { offset, element: child };
            return closest;
          },
          { offset: Number.NEGATIVE_INFINITY }
        ).element;
      }
    </script>
    <!-- å¯Œæ–‡æœ¬ç¼–è¾‘åŠŸèƒ½ -->
    <script>
      //å¯Œæ–‡æœ¬åŠŸèƒ½
      let currentRange = null; // å­˜å‚¨ç”¨æˆ·é€‰æ‹©çš„æ–‡æœ¬èŒƒå›´
      editorContainer.addEventListener("mouseup", () => {
        setTimeout(() => {
          // å»¶è¿Ÿæ‰§è¡Œä»¥ç¡®ä¿æµè§ˆå™¨æ­£ç¡®è·å–é€‰åŒº
          const sel = window.getSelection();
          if (sel && !sel.isCollapsed && editor.contains(sel.anchorNode)) {
            // âœ… åˆ¤æ–­é€‰ä¸­æ–‡æœ¬æ˜¯å¦åœ¨æŒ‡å®šå…ƒç´ å†…éƒ¨,ä¸ç”Ÿæ•ˆ
            const invalidElements = editor.querySelectorAll("code, code span");
            for (let el of invalidElements) {
              if (el.contains(sel.anchorNode)) return;
            }
            // ä¿å­˜é€‰åŒº
            currentRange = sel.getRangeAt(0).cloneRange();
            const rect = currentRange.getBoundingClientRect();
            // å®šä½å·¥å…·æ 
            floatingToolbar.style.left = `${
              rect.left +
              window.scrollX +
              rect.width / 2 -
              floatingToolbar.offsetWidth / 2
            }px`;
            floatingToolbar.style.top = `${
              rect.top + window.scrollY - floatingToolbar.offsetHeight - 8
            }px`;
            floatingToolbar.style.display = "flex";
          } else {
            floatingToolbar.style.display = "none";
            colorPalette.classList.remove("visible");
          }
        }, 10);
      });
      document.addEventListener("mousedown", (e) => {
        // åˆ¤æ–­ç‚¹å‡»æ˜¯å¦åœ¨å·¥å…·æ 
        if (!floatingToolbar.contains(e.target)) {
          // 1ï¸âƒ£ æ¸…ç©ºé€‰åŒº
          const sel = window.getSelection();
          if (sel) sel.removeAllRanges();

          // 2ï¸âƒ£ ç§»é™¤é€‰ä¸­æ–‡æœ¬é«˜äº®ï¼ˆå¦‚æœä½ æ˜¯ç”¨ class æ¥é«˜äº®ï¼‰
          const highlighted = editorContainer.querySelectorAll(".highlight");
          highlighted.forEach((el) => el.classList.remove("highlight"));

          // 3ï¸âƒ£ éšè—æµ®åŠ¨å·¥å…·æ å’Œé¢œè‰²é¢æ¿
          floatingToolbar.style.display = "none";
          colorPalette.classList.remove("visible");

          // é‡ç½® currentRange
          currentRange = null;
        }
      });
      function initColorPalette() {
        PALETTE_COLORS.forEach((color) => {
          const swatch = document.createElement("button");
          swatch.className = "color-swatch";
          swatch.style.backgroundColor = color;
          swatch.dataset.color = color;
          colorPalette.appendChild(swatch);
        });
      }
      colorBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        colorPalette.classList.toggle("visible");
      });
      colorPalette.addEventListener("click", (e) => {
        if (e.target.classList.contains("color-swatch")) {
          e.stopPropagation();
          const color = e.target.dataset.color;
          applyFormat("foreColor", color);
          colorPalette.classList.remove("visible");
        }
      });

      function applyFormat(cmd, val = null) {
        if (!currentRange) return;
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(currentRange);
        document.execCommand(cmd, false, val);
        floatingToolbar.style.display = "none";
        currentRange = null;
        saveEditorState();
      }
      document
        .getElementById("bold-btn")
        .addEventListener("click", () => applyFormat("bold"));
      document
        .getElementById("italic-btn")
        .addEventListener("click", () => applyFormat("italic"));
      document
        .getElementById("underline-btn")
        .addEventListener("click", () => applyFormat("underline"));
      document
        .getElementById("clear-format-btn")
        .addEventListener("click", () => {
          applyFormat("removeFormat");
          applyFormat("unlink");
        });
      document.getElementById("link-btn").addEventListener("click", () => {
        if (!currentRange) return;
        const url = prompt("è¾“å…¥é“¾æ¥ URL:", "https://");
        if (url) applyFormat("createLink", url);
      });
    </script>
    <!-- å‘½ä»¤é¢æ¿å¿«æ·é”® -->
    <script>
      function detectBackticksAtCaret() {
        const sel = window.getSelection();

        if (!sel.isCollapsed || !sel.rangeCount) return false;

        const range = sel.getRangeAt(0);

        const node = range.startContainer;

        const offset = range.startOffset;

        if (node.nodeType !== Node.TEXT_NODE) return false;

        const textBeforeCaret = node.textContent.substring(0, offset);
        //endwithæ˜¯å…‰æ ‡,å¦‚æœå…‰æ ‡å‰æ˜¯``,åˆ™è§¦å‘å·¥å…·é¢æ¿
        if (textBeforeCaret.endsWith("-=")) {
          const contentEl = node.parentElement.closest(".content");

          if (!contentEl) return false;

          const block = contentEl.closest(".block, li.block");

          if (!block) return false;

          const newRange = document.createRange();

          newRange.setStart(node, offset - 2);

          newRange.setEnd(node, offset);

          newRange.deleteContents();

          const rect = range.getBoundingClientRect();

          cmdMenuState.triggerBlock = block;

          cmdMenuState.triggerRect = rect;

          cmdMenuState.selectedIndex = 0;

          const menu = createAddMenu(
            block.parentElement,
            block.nextElementSibling,
            true
          );

          cmdMenuState.active = true;

          cmdMenuState.element = menu;

          updateCmdMenuSelection();

          return true;
        }
        return false;
      }
      editor.addEventListener("input", (e) => {
        detectBackticksAtCaret();
      });
    </script>
    <!-- å¿«æ·é”® -->
    <script>
      // âœ… åŠŸèƒ½æ€»ç»“ï¼š
      // æ’¤é”€/é‡åš
      // Mac: Cmd+Z æ’¤é”€ï¼ŒCmd+Shift+Z é‡åš
      // Windows: Ctrl+Z æ’¤é”€ï¼ŒCtrl+Y é‡åš
      // å‘½ä»¤èœå•å¿«æ·é”®
      // ArrowDown/ArrowUp: ç§»åŠ¨èœå•é«˜äº®
      // Enter: æ‰§è¡Œé€‰ä¸­èœå•é¡¹
      // Escape: å…³é—­èœå•
      // Shift+Enter èšç„¦æ§åˆ¶
      // åœ¨å†…å®¹å—å†…æŒ‰ Shift+Enter ä¼šå–æ¶ˆç„¦ç‚¹ï¼Œè€Œä¸æ˜¯æ¢è¡Œ

      // ç›‘å¬å…¨å±€æŒ‰é”®äº‹ä»¶
      document.addEventListener("keydown", (e) => {
        // åˆ¤æ–­å½“å‰ç³»ç»Ÿæ˜¯å¦ä¸º Mac
        const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;

        // æ ¹æ®ç³»ç»Ÿé€‰æ‹©ä¿®é¥°é”®ï¼šMac ç”¨ metaKeyï¼ˆâŒ˜ï¼‰ï¼Œé Mac ç”¨ ctrlKey
        const mod = isMac ? e.metaKey : e.ctrlKey;

        // --- æ’¤é”€æ“ä½œ Ctrl/Cmd + Z ---
        if (mod && !e.shiftKey && e.key.toLowerCase() === "z") {
          e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤æ’¤é”€è¡Œä¸º
          undo(); // æ‰§è¡Œè‡ªå®šä¹‰æ’¤é”€å‡½æ•°
          return; // é€€å‡ºç›‘å¬
        }

        // --- é‡åšæ“ä½œ Ctrl/Cmd + Shift + Z æˆ– Ctrl/Cmd + Y ---
        if (
          (mod && e.shiftKey && e.key.toLowerCase() === "z") || // Mac å¸¸ç”¨ Cmd+Shift+Z
          (mod && e.key.toLowerCase() === "y") // Windows å¸¸ç”¨ Ctrl+Y
        ) {
          e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤é‡åšè¡Œä¸º
          redo(); // æ‰§è¡Œè‡ªå®šä¹‰é‡åšå‡½æ•°
          return; // é€€å‡ºç›‘å¬
        }

        // --- å‘½ä»¤èœå•å¯¼èˆª ---
        // å½“å‘½ä»¤èœå•å¤„äºæ¿€æ´»çŠ¶æ€ä¸”å­˜åœ¨ DOM å…ƒç´ 
        if (cmdMenuState.active && cmdMenuState.element) {
          const opts = cmdMenuState.element.querySelectorAll("button"); // è·å–æ‰€æœ‰èœå•é€‰é¡¹æŒ‰é’®
          if (!opts.length) return; // æ²¡æœ‰é€‰é¡¹åˆ™è¿”å›

          if (e.key === "ArrowDown") {
            e.preventDefault(); // é˜»æ­¢é»˜è®¤æ»šåŠ¨
            // ä¸‹ç§»é€‰ä¸­ç´¢å¼•ï¼Œå¾ªç¯å›åˆ°ç¬¬ä¸€é¡¹
            cmdMenuState.selectedIndex =
              (cmdMenuState.selectedIndex + 1) % opts.length;
            updateCmdMenuSelection(); // æ›´æ–°èœå•é«˜äº®æ˜¾ç¤º
          } else if (e.key === "ArrowUp") {
            e.preventDefault(); // é˜»æ­¢é»˜è®¤æ»šåŠ¨
            // ä¸Šç§»é€‰ä¸­ç´¢å¼•ï¼Œå¾ªç¯å›åˆ°æœ€åä¸€é¡¹
            cmdMenuState.selectedIndex =
              (cmdMenuState.selectedIndex - 1 + opts.length) % opts.length;
            updateCmdMenuSelection(); // æ›´æ–°èœå•é«˜äº®æ˜¾ç¤º
          } else if (e.key === "Enter") {
            e.preventDefault(); // é˜»æ­¢é»˜è®¤æ¢è¡Œ
            // æ‰§è¡Œå½“å‰é€‰ä¸­èœå•é¡¹çš„ç‚¹å‡»äº‹ä»¶
            opts[cmdMenuState.selectedIndex].click();
          } else if (e.key === "Escape") {
            e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸º
            closeAllMenus(); // å…³é—­æ‰€æœ‰èœå•
          }
        }

        // --- Shift + Enter å–æ¶ˆå½“å‰å†…å®¹å—ç„¦ç‚¹ ---
        if (e.shiftKey && e.key === "Enter") {
          const active = document.activeElement; // è·å–å½“å‰èšç„¦å…ƒç´ 
          if (
            active &&
            active.classList && // ç¡®ä¿å…ƒç´ æœ‰ classList å±æ€§
            active.classList.contains("content") // åªå¤„ç† .content å—
          ) {
            active.blur(); // ç§»é™¤ç„¦ç‚¹
            e.preventDefault(); // é˜»æ­¢é»˜è®¤æ¢è¡Œ
          }
        }
      });
    </script>
    <!-- ç²˜è´´ -->
    <script>
      editor.addEventListener("paste", async (e) => {
        if (!e.clipboardData) return;
        const items = Array.from(e.clipboardData.items || []);
        const imageItem = items.find(
          (it) => it.type && it.type.startsWith("image/")
        );
        if (imageItem) {
          e.preventDefault();
          const file = imageItem.getAsFile();
          const dataUrl = await fileToDataURL(file);
          const activeBlock =
            document.activeElement.closest(".block") ||
            document.activeElement.closest("li.block") ||
            null;
          const parent = activeBlock ? activeBlock.parentElement : editor;
          const after = activeBlock ? activeBlock.nextElementSibling : null;
          const imgBlock = createBlock("img", "", { src: dataUrl });
          parent.insertBefore(imgBlock, after);
          saveEditorState();
        }
      });
    </script>
    <!-- æ·»åŠ å—-èœå•(åŒå‡») -->
    <script>
      // æ•´ä¸ªå®¹å™¨ç›‘å¬åŒå‡»äº‹ä»¶
      editorContainer.addEventListener("dblclick", (e) => {
        const target = e.target;
        // å¦‚æœåŒå‡»çš„æ˜¯å¯ç¼–è¾‘å—ï¼Œä»¥åŠä»–çš„çˆ¶çº§æ˜¯å¯ç¼–è¾‘å—ï¼ŒæŒ‰é’®ï¼Œselectï¼Œaï¼Œsummaryï¼Œdrag-handle
        // ç›´æ¥è¿”å›
        if (
          target.isContentEditable ||
          target.closest(
            "[contenteditable], button, select, a, summary, .drag-handle"
          )
        )
          return;
        // é˜»æ­¢æµè§ˆå™¨é»˜è®¤è¡Œä¸ºï¼Œé˜»æ­¢å†’æ³¡ï¼Œå…³é—­æ‰€æœ‰èœå•
        e.preventDefault();
        e.stopPropagation();
        closeAllMenus();
        //
        let parent = editor;
        let before = null;
        const closest = target.closest(".block") || target.closest("li.block");
        if (closest) {
          const kids = closest.querySelector(".block-children");
          if (kids && kids.contains(target)) {
            parent = kids;
            before = getDragAfterElement(kids, e.clientY);
          } else if (kids) {
            parent = kids;
            before = null;
          } else {
            parent = closest.parentElement;
            before = closest.nextElementSibling;
          }
        } else {
          parent = editor;
          before = getDragAfterElement(editor, e.clientY);
        }
        createAddMenu(parent, before, false, e);
      });
      //æ–‡æ¡£
      document.addEventListener("click", (e) => {
        if (!e.target.closest(".add-menu")) {
          closeAllMenus();
        }
      });
      document.addEventListener("scroll", () => closeAllMenus(), true);
    </script>
    <!-- è¡¨æ ¼(æ§åˆ¶æŒ‰é’®äº‹ä»¶) -->
    <script>
      editor.addEventListener("click", (e) => {
        const t = e.target;
        if (
          t.classList.contains("add-row") ||
          t.classList.contains("add-col") ||
          t.classList.contains("del-row") ||
          t.classList.contains("del-col")
        ) {
          const block = t.closest(".block");
          if (!block) return;
          const table = block.querySelector("table");
          if (!table) return;
          if (t.classList.contains("add-row")) {
            const cols = table.querySelector("thead tr").cells.length;
            const row = table.querySelector("tbody").insertRow();
            for (let i = 0; i < cols; i++) {
              const c = row.insertCell();
              c.setAttribute("contenteditable", "true");
              c.textContent = "";
            }
          } else if (t.classList.contains("add-col")) {
            table.querySelectorAll("tr").forEach((r, idx) => {
              const cell =
                r.parentElement.tagName === "THEAD"
                  ? document.createElement("th")
                  : document.createElement("td");
              cell.setAttribute("contenteditable", "true");
              cell.textContent = "";
              r.appendChild(cell);
            });
          } else if (t.classList.contains("del-row")) {
            const tbody = table.querySelector("tbody");
            if (tbody.rows.length > 1) tbody.deleteRow(-1);
          } else if (t.classList.contains("del-col")) {
            const colCount = table.querySelector("thead tr").cells.length;
            if (colCount > 1)
              table.querySelectorAll("tr").forEach((r) => r.deleteCell(-1));
          }
          saveEditorState();
        }
      });
    </script>
    <!-- é»˜è®¤å›è½¦æ·»åŠ pæ®µè½ -->
    <script>
      let lastKeyWasEnter = false; // è®°å½•ä¸Šä¸€æ¬¡æ˜¯å¦æŒ‰ä¸‹äº† Enter
      editor.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") {
          lastKeyWasEnter = false; // å…¶ä»–é”®å°±é‡ç½®
          return;
        }
        const sel = window.getSelection();
        if (!sel.rangeCount) return;

        const node = sel.anchorNode;
        let contentEl =
          node.nodeType === 3
            ? node.parentElement.closest(".content")
            : node.closest(".content");
        if (!contentEl) return;

        const type = contentEl.dataset.type;
        // --- p / pre / heading / img / blockquote ---------------------------
        if (["p", "pre", "heading", "img", "blockquote"].includes(type)) {
          if (lastKeyWasEnter) {
            // ç¬¬äºŒæ¬¡ Enter â†’ æ’å…¥æ–°æ®µè½
            e.preventDefault();
            // æŠŠå‰ä¸€ä¸ªå—æœ«å°¾çš„æ¢è¡Œåˆ é™¤
            contentEl.innerText = contentEl.innerText.replace(/\n$/, "");

            const currentBlock = contentEl.closest(".block");
            const newP = createBlock("p", "");

            currentBlock.parentElement.insertBefore(
              newP,
              currentBlock.nextElementSibling
            );

            newP.querySelector(".content")?.focus();
            saveEditorState();

            lastKeyWasEnter = false; // é‡ç½®
          } else {
            // ç¬¬ä¸€æ¬¡ Enter â†’ åªæ˜¯è®°å½•ï¼Œä¸æ’å…¥æ®µè½
            lastKeyWasEnter = true;

            // å¯é€‰ï¼šå»¶æ—¶è‡ªåŠ¨æ¸…é›¶ï¼Œé¿å…ç”¨æˆ·å¾ˆä¹…ä»¥åå†æŒ‰ Enter è¿˜è¢«åˆ¤å®šä¸ºåŒ Enter
            setTimeout(() => {
              lastKeyWasEnter = false;
            }, 500); // åŠç§’æœ‰æ•ˆçª—å£
          }
        }
      });
    </script>
    <!-- åˆ—è¡¨å›è½¦æ·»åŠ  -->
    <script>
      // âœ… åŠŸèƒ½æ€»ç»“ï¼š
      // åªåœ¨æŒ‰ä¸‹ Enter ä¸”å…‰æ ‡åœ¨åˆ—è¡¨é¡¹æˆ–ä»»åŠ¡é¡¹æ—¶è§¦å‘ã€‚
      // ç©ºåˆ—è¡¨é¡¹æŒ‰ Enter â†’ è½¬ä¸ºæ™®é€šæ®µè½å¹¶åˆ é™¤ç©ºåˆ—è¡¨é¡¹ï¼Œå¦‚æœåˆ—è¡¨ç©ºåˆ™æ•´ä¸ªåˆ—è¡¨åˆ é™¤ã€‚
      // éç©ºåˆ—è¡¨é¡¹æŒ‰ Enter â†’ æ–°å¢åŒç±»å‹åˆ—è¡¨é¡¹ã€‚
      // å…‰æ ‡è‡ªåŠ¨è·³è½¬åˆ°æ–°å—æˆ–æ–°åˆ—è¡¨é¡¹ã€‚
      // ä¿å­˜ç¼–è¾‘å™¨çŠ¶æ€ã€‚

      // ç»™æ•´ä¸ªç¼–è¾‘å™¨ç›‘å¬æŒ‰é”®äº‹ä»¶
      editor.addEventListener("keydown", (e) => {
        // ä¸æ˜¯enteré”®å°±ç»“æŸå‡½æ•°
        if (e.key !== "Enter") return;

        // å…‰æ ‡ç°åœ¨åœ¨å“ªé‡Œï¼Ÿé€‰ä¸­äº†å“ªäº›æ–‡æœ¬ï¼Ÿæ²¡æœ‰æ–‡æœ¬ä¼šè¿”å› 1ï¼ˆå…‰æ ‡ä½ç½®ä¹Ÿç®—ä¸€ä¸ª Rangeï¼‰
        const sel = window.getSelection();
        if (!sel.rangeCount) return;

        const node = sel.anchorNode; // è·å–å…‰æ ‡æ‰€åœ¨èŠ‚ç‚¹

        // è·å–å¯ç¼–è¾‘å†…å®¹å—
        // å¦‚æœå…‰æ ‡åœ¨æ–‡æœ¬èŠ‚ç‚¹ (nodeType === 3)ï¼Œåˆ™å–çˆ¶å…ƒç´ ï¼Œå†å‘ä¸Šå¯»æ‰¾æœ€è¿‘çš„ .content å…ƒç´ 
        // å¦åˆ™ç›´æ¥åœ¨èŠ‚ç‚¹ä¸Šå¯»æ‰¾æœ€è¿‘çš„ .content å…ƒç´ 
        let contentEl =
          node.nodeType === 3
            ? node.parentElement.closest(".content")
            : node.closest(".content");
        if (!contentEl) return; // å¦‚æœæ²¡æœ‰æ‰¾åˆ° .content å…ƒç´ ï¼Œç›´æ¥è¿”å›

        const type = contentEl.dataset.type; // è·å–å½“å‰å†…å®¹å—çš„ typeï¼Œä¾‹å¦‚ "li" æˆ– "taskitem"

        // åªå¤„ç†åˆ—è¡¨é¡¹æˆ–ä»»åŠ¡é¡¹
        if (type === "li" || type === "taskitem") {
          e.preventDefault(); // é˜»æ­¢é»˜è®¤ Enter è¡Œä¸ºï¼ˆæ¢è¡Œï¼‰

          const currentItem = contentEl.closest("li.block"); // å½“å‰åˆ—è¡¨é¡¹çš„ li.block
          const listContainer = currentItem.parentElement; // å½“å‰åˆ—è¡¨çš„å®¹å™¨ï¼ˆul æˆ– olï¼‰
          const listWrapperBlock = listContainer.closest(".block"); // æ•´ä¸ªåˆ—è¡¨æ‰€åœ¨çš„ block

          // å¦‚æœå½“å‰åˆ—è¡¨é¡¹å†…å®¹ä¸ºç©º
          if (contentEl.textContent.trim() === "") {
            // åˆ›å»ºä¸€ä¸ªæ–°çš„æ™®é€šæ®µè½å—
            const newP = createBlock("p", "");

            // å°†æ–°æ®µè½æ’å…¥åˆ°åˆ—è¡¨æ‰€åœ¨å—ä¹‹å
            listWrapperBlock.parentElement.insertBefore(
              newP,
              listWrapperBlock.nextElementSibling
            );

            // åˆ é™¤å½“å‰ç©ºåˆ—è¡¨é¡¹
            currentItem.remove();

            // å¦‚æœåˆ—è¡¨å®¹å™¨å·²ç»æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œåˆ é™¤æ•´ä¸ªåˆ—è¡¨å—
            if (!listContainer.hasChildNodes()) {
              listWrapperBlock.remove();
            }

            // å°†å…‰æ ‡èšç„¦åˆ°æ–°æ®µè½çš„å†…å®¹å—ä¸­
            newP.querySelector(".content")?.focus();
          } else {
            // å½“å‰åˆ—è¡¨é¡¹æœ‰å†…å®¹ï¼ŒæŒ‰ Enter åªæ˜¯åˆ†å‡ºæ–°åˆ—è¡¨é¡¹
            const newItem = createBlock(type, ""); // åˆ›å»ºç›¸åŒç±»å‹çš„åˆ—è¡¨é¡¹
            listContainer.insertBefore(
              newItem,
              currentItem.nextElementSibling // æ’å…¥åˆ°å½“å‰åˆ—è¡¨é¡¹åé¢
            );

            // å…‰æ ‡èšç„¦åˆ°æ–°åˆ—è¡¨é¡¹çš„å†…å®¹å—ä¸­
            newItem.querySelector(".content")?.focus();
          }

          // ä¿å­˜ç¼–è¾‘å™¨çŠ¶æ€ï¼ˆé˜²æ­¢æ•°æ®ä¸¢å¤±ï¼‰
          saveEditorState();
        }
      });
    </script>
    <!-- [æ ¸å¿ƒå‡½æ•°] åºåˆ—åŒ–-å°†ç¼–è¾‘å™¨ä¸­çš„ä¸€ä¸ªå—åŠå…¶å­å—è½¬æ¢ä¸ºJSON å¯¹è±¡(ä¸æ‡‚??) -->
    <script>
      function serializeBlock(block) {
        const type = block.dataset.type;
        const data = { type };
        if (type === "li" || type === "taskitem") {
          const contentEl = block.querySelector(".content");
          if (contentEl) data.content = contentEl.innerHTML;
          if (type === "taskitem")
            data.checked = !!block.querySelector(".task-checkbox")?.checked;
          return data;
        }
        const contentEl = block.querySelector(".content");
        if (contentEl) data.content = contentEl.innerHTML;
        if (type === "heading") {
          data.level =
            parseInt(block.querySelector(".content")?.dataset.level, 10) || 2;
        }
        if (type === "pre") {
          data.lang = block.dataset.lang || "javascript";
          data.content = block.querySelector("code")?.textContent || "";
        }
        if (type === "table") {
          data.tableContent = block.querySelector("table")?.innerHTML || "";
        }
        if (type === "img") {
          const img = block.querySelector("img");
          if (img) data.src = img.src;
        }
        const details = block.querySelector(":scope > details");
        if (details) data.openState = details.open;
        const childrenContainer = block.querySelector(
          ":scope > .block-children, :scope > details > .block-children"
        );
        if (childrenContainer && childrenContainer.children.length > 0) {
          data.children = [...childrenContainer.children]
            .filter(
              (c) =>
                c.classList &&
                (c.classList.contains("block") || c.tagName === "LI")
            )
            .map(serializeBlock);
        }
        return data;
      }
    </script>
    <!-- [æ ¸å¿ƒå‡½æ•°]ä¿å­˜ç¼–è¾‘å™¨çŠ¶æ€åˆ°localStorage -->
    <script>
      const saveEditorState = debounce(() => {
        if (historyLock) return;
        try {
          const arr = [...editor.children]
            .filter((c) => c.classList && c.classList.contains("block"))
            .map(serializeBlock);
          const s = JSON.stringify(arr);
          localStorage.setItem(LOCAL_STORAGE_KEY, s);
          snapshot(s);
        } catch (e) {
          console.warn("save fail", e);
        }
      }, 400);
    </script>
    <!-- [æ ¸å¿ƒå‡½æ•°]ä»localStorageåŠ è½½ç¼–è¾‘å™¨çŠ¶æ€ -->
    <!-- å¦‚æœæ²¡æœ‰localstorage,åˆ™ä¸ºfalse -->
    <script>
      function loadEditorState() {
        const s = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!s) return false;
        try {
          const arr = JSON.parse(s);
          editor.innerHTML = "";
          arr.forEach((d) => {
            const b = createBlock(d.type, "", d);
            if (b) editor.appendChild(b);
          });
          editor
            .querySelectorAll("pre code")
            .forEach((c) => Prism.highlightElement(c));
          updateAllHeadingNumbers();
          history = [];
          historyIndex = -1;
          snapshot(s);
          return true;
        } catch (e) {
          console.error("load fail", e);
          return false;
        }
      }
    </script>
    <!-- æ’¤é”€/é‡åšåŠŸèƒ½ -->
    <script>
      function snapshot(serialized) {
        try {
          const s =
            serialized ||
            JSON.stringify(
              [...editor.children]
                .filter((c) => c.classList.contains("block"))
                .map(serializeBlock)
            );
          if (!s) return;
          if (historyIndex < history.length - 1)
            history = history.slice(0, historyIndex + 1);
          history.push(s);
          if (history.length > HISTORY_LIMIT) history.shift();
          historyIndex = history.length - 1;
        } catch (e) {
          console.warn("snapshot fail", e);
        }
      }
      function applySnapshot(serialized) {
        try {
          historyLock = true;
          const arr = JSON.parse(serialized);
          editor.innerHTML = "";
          arr.forEach((d) => {
            const b = createBlock(d.type, "", d);
            if (b) editor.appendChild(b);
          });
          editor
            .querySelectorAll("pre code")
            .forEach((c) => Prism.highlightElement(c));
          updateAllHeadingNumbers();
        } catch (e) {
          console.error("apply snapshot fail", e);
        } finally {
          historyLock = false;
        }
      }
      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          applySnapshot(history[historyIndex]);
        }
      }
      function redo() {
        if (historyIndex < history.length - 1) {
          historyIndex++;
          applySnapshot(history[historyIndex]);
        }
      }
    </script>
    <!-- [æ ¸å¿ƒåŠŸèƒ½]é€’å½’æ›´æ–°æ‰€æœ‰æ ‡é¢˜çš„ç¼–å·(å¦‚1.ï¼Œ1.1ï¼Œ1.2.ï¼Œ2.) -->
    <script>
      function updateAllHeadingNumbers() {
        function walk(container, prefix = "", level = 0) {
          let idx = 1;
          [...container.children]
            .filter((ch) => ch.classList && ch.classList.contains("block"))
            .forEach((child) => {
              if (child.dataset.type === "heading") {
                const num = prefix ? `${prefix}.${idx}` : `${idx}`;
                const span = child.querySelector(".heading-number");
                if (span) span.textContent = num + ". ";
                const contentEl = child.querySelector(".content");
                if (contentEl) {
                  const wantTag = `h${Math.min(6, level + 1)}`;
                  if (contentEl.tagName.toLowerCase() !== wantTag) {
                    const newH = document.createElement(wantTag);
                    newH.className = "content";
                    newH.setAttribute("contenteditable", "true");
                    newH.innerHTML = contentEl.innerHTML;
                    newH.dataset.type = "heading";
                    newH.dataset.level = level + 1;
                    contentEl.replaceWith(newH);
                    newH.addEventListener(
                      "input",
                      debounce(() => saveEditorState(), 400)
                    );
                  } else {
                    contentEl.dataset.level = level + 1;
                  }
                }
                const kids = child.querySelector(".block-children");
                if (kids) walk(kids, num, level + 1);
                idx++;
              }
            });
        }
        walk(editor);
        updateToc();
      }
    </script>
    <!-- [æ ¸å¿ƒåŠŸèƒ½]è§£æ Markdown æ–‡æœ¬å¹¶æ’å…¥åˆ°ç¼–è¾‘å™¨ -->
    <script>
      function parseAndInsertMarkdown(
        mdText,
        targetContainer = editor,
        beforeEl = null
      ) {
        const md = window.markdownit
          ? window.markdownit({
              html: true,
              linkify: true,
              typographer: true,
            })
          : null;
        if (!md) {
          console.error("markdown-it library not found!");
          return;
        }
        const html = md.render(mdText);
        const tmp = document.createElement("div");
        tmp.innerHTML = html;
        const parentStack = [{ container: targetContainer, level: 0 }];
        Array.from(tmp.childNodes).forEach((node) => {
          if (node.nodeType !== Node.ELEMENT_NODE) return;
          const name = node.nodeName.toLowerCase();
          let newBlock = null;
          if (name.match(/^h([1-6])$/)) {
            const level = parseInt(RegExp.$1, 10);
            newBlock = createBlock("heading", "", {
              level,
              content: node.innerHTML,
              openState: true,
            });
            while (
              parentStack.length > 1 &&
              parentStack[parentStack.length - 1].level >= level
            ) {
              parentStack.pop();
            }
            const currentParent = parentStack[parentStack.length - 1].container;
            currentParent.appendChild(newBlock);
            parentStack.push({
              container: newBlock.querySelector(".block-children"),
              level: level,
            });
          } else {
            if (name === "p")
              newBlock = createBlock("p", "", { content: node.innerHTML });
            else if (name === "pre") {
              const code = node.querySelector("code");
              const lang =
                code && code.className.match(/language-(\S+)/)
                  ? RegExp.$1
                  : "plaintext";
              newBlock = createBlock("pre", "", {
                content: code ? code.textContent : node.textContent,
                lang,
              });
            } else if (name === "ul") {
              const lis = Array.from(node.querySelectorAll(":scope > li"));
              const isTask = lis.some((li) =>
                /^\s*\[[ xX]\]\s*/.test(li.textContent)
              );
              if (isTask) {
                newBlock = createBlock("task");
                const cont = newBlock.querySelector(".block-children");
                lis.forEach((li) => {
                  const text = li.innerHTML
                    .replace(/^\s*<input[^>]*>\s*/, "")
                    .replace(/^\s*\[[ xX]\]\s*/, "");
                  const checked =
                    /^\s*\[[xX]\]/.test(li.innerHTML) ||
                    (li.firstChild && li.firstChild.checked);
                  cont.appendChild(
                    createBlock("taskitem", "", { content: text, checked })
                  );
                });
              } else {
                newBlock = createBlock("ul");
                const cont = newBlock.querySelector(".block-children");
                lis.forEach((li) =>
                  cont.appendChild(
                    createBlock("li", "", { content: li.innerHTML })
                  )
                );
              }
            } else if (name === "ol") {
              newBlock = createBlock("ol");
              const cont = newBlock.querySelector(".block-children");
              node
                .querySelectorAll(":scope > li")
                .forEach((li) =>
                  cont.appendChild(
                    createBlock("li", "", { content: li.innerHTML })
                  )
                );
            } else if (name === "blockquote")
              newBlock = createBlock("blockquote", "", {
                content: node.innerHTML,
              });
            else if (name === "table")
              newBlock = createBlock("table", "", {
                tableContent: node.innerHTML,
              });
            else if (name === "img")
              newBlock = createBlock("img", "", {
                src: node.getAttribute("src"),
              });
            else newBlock = createBlock("p", "", { content: node.outerHTML });
            if (newBlock) {
              const currentParent =
                parentStack[parentStack.length - 1].container;
              currentParent.appendChild(newBlock);
            }
          }
        });
        updateAllHeadingNumbers();
        saveEditorState();
      }
    </script>
    <!-- [æ ¸å¿ƒåŠŸèƒ½]å¯¼å‡ºç¼–è¾‘å™¨å†…å®¹ä¸º Markdown æ–‡ä»¶ -->
    <script>
      function exportToMarkdown() {
        if (typeof TurndownService === "undefined") {
          console.error("Turndown library not found!");
          return;
        }
        const turndownService = new TurndownService({ headingStyle: "atx" });
        turndownService.addRule("taskListItem", {
          filter: function (node, options) {
            return (
              node.nodeName === "LI" &&
              node.classList.contains("block") &&
              node.dataset.type === "taskitem"
            );
          },
          replacement: function (content, node) {
            const checkbox = node.querySelector(".task-checkbox");
            const checked = checkbox && checkbox.checked ? "[x]" : "[ ]";
            const contentDiv = node.querySelector(".content");
            const innerContent = turndownService.turndown(contentDiv || "");
            return `- ${checked} ${innerContent}`;
          },
        });
        turndownService.addRule("taskListContainer", {
          filter: function (node) {
            return node.nodeName === "DIV" && node.dataset.type === "task";
          },
          replacement: function (content) {
            return content;
          },
        });
        const clone = editor.cloneNode(true);
        clone
          .querySelectorAll(
            ".drag-handle, .delete-btn, .code-toolbar, .heading-number, .task-checkbox"
          )
          .forEach((n) => n.remove());
        const md = turndownService.turndown(clone);
        const MdFILE_NAME = FILE_NAME.replace(/\.[^/.]+$/, "") + ".md";
        downloadFile(MdFILE_NAME, md, "text/markdown");
      }
    </script>
    <!-- FABï¼ˆæ‚¬æµ®æ“ä½œæŒ‰é’®ï¼‰ç›¸å…³åŠŸèƒ½ -->
    <script>
      const mdInput = document.createElement("input");
      mdInput.type = "file";
      mdInput.accept = ".md,.markdown,.txt";
      mdInput.style.display = "none";
      mdInput.addEventListener("change", async (e) => {
        const f = e.target.files[0];
        if (!f) return;
        const txt = await f.text();
        parseAndInsertMarkdown(txt, editor, null);
        e.target.value = "";
      });
      document.body.appendChild(mdInput);
      function downloadHTML() {
        // è·å–å®Œæ•´ HTMLï¼ˆåŒ…å« <html>ã€<head>ã€<body>ï¼‰
        const fullHTML =
          "<!doctype html>\n" + document.documentElement.outerHTML;
        // ä»urlè·å–å½“å‰æ–‡ä»¶åï¼ˆè§£ç ä¸­æ–‡ï¼‰
        let filename = decodeURIComponent(
          location.pathname.split("/").pop() || "document.html"
        );

        // é˜²æ­¢éæ³•æ–‡ä»¶åå­—ç¬¦
        filename = FILE_NAME;

        // å¦‚æœæ²¡æœ‰æ‰©å±•åï¼Œè¡¥ä¸Š .html
        if (!filename.includes(".")) {
          filename += ".html";
        }
        // è°ƒç”¨ä¸‹è½½æ–‡ä»¶å‡½æ•°
        downloadFile(filename, fullHTML, "text/html");
        localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
      //æ¸…ç©ºeditorçš„å†…å®¹
      function clearAll() {
        const editor = document.getElementById("editor");
        if (editor) {
          editor.innerHTML = "";
        }
      }
      //æŠ˜å æ‰€æœ‰æ ‡é¢˜
      function FoldHeading() {
        document.querySelectorAll("details").forEach((detail) => {
          if (detail.hasAttribute("open")) {
            detail.removeAttribute("open");
          }
        });
      }

      function exportToPDF() {
        if (typeof html2pdf === "undefined") {
          console.error("html2pdf library not found!");
          return;
        }
        const node = editor.cloneNode(true);
        node.style.padding = "20px";
        node
          .querySelectorAll(
            ".drag-handle, .delete-btn, .code-toolbar, .table-controls"
          )
          .forEach((n) => n.remove());
        const opt = {
          margin: 10,
          filename: "document.pdf",
          image: { type: "jpeg", quality: 0.98 },
          html2canvas: { scale: 2 },
          jsPDF: { unit: "mm", format: "a4", orientation: "portrait" },
        };
        html2pdf().set(opt).from(node).save();
      }
      const fabMain = document.getElementById("fab-main");
      const fabMenu = document.getElementById("fab-menu");
      fabMain.addEventListener("click", (e) => {
        e.stopPropagation();
        fabMenu.style.display =
          fabMenu.style.display === "flex" ? "none" : "flex";
      });
      document.addEventListener("click", (e) => {
        if (!e.target.closest("#fab")) fabMenu.style.display = "none";
      });
      document.getElementById("fab-import").addEventListener("click", () => {
        mdInput.click();
        fabMenu.style.display = "none";
      });
      document.getElementById("fab-export-md").addEventListener("click", () => {
        exportToMarkdown();
        fabMenu.style.display = "none";
      });
      document
        .getElementById("fab-export-pdf")
        .addEventListener("click", () => {
          exportToPDF();
          fabMenu.style.display = "none";
        });
      document.getElementById("fab-save").addEventListener("click", () => {
        downloadHTML();
        fabMenu.style.display = "none";
      });
      document.getElementById("fab-fold").addEventListener("click", () => {
        FoldHeading();
        fabMenu.style.display = "none";
      });
      document.getElementById("fab-clean-all").addEventListener("click", () => {
        clearAll();
        fabMenu.style.display = "none";
      });
      document.getElementById("fab-clear").addEventListener("click", () => {
        if (confirm("ç¡®è®¤æ¸…ç©ºæœ¬åœ°ä¿å­˜ï¼Ÿ")) {
          localStorage.removeItem(LOCAL_STORAGE_KEY);
          window.location.reload();
        }
        fabMenu.style.display = "none";
      });
    </script>
    <!-- TOC ï¼ˆç›®å½•)ç›¸å…³åŠŸèƒ½ -->
    <script>
      const tocList = document.getElementById("toc-list");
      const tocFab = document.getElementById("toc-fab");
      const tocPanel = document.getElementById("toc-panel");
      let tocHideTimeout = null;

      tocFab.addEventListener("mouseenter", () => {
        clearTimeout(tocHideTimeout);
        tocPanel.classList.add("is-visible");
      });

      tocFab.addEventListener("mouseleave", () => {
        tocHideTimeout = setTimeout(() => {
          tocPanel.classList.remove("is-visible");
        }, 300);
      });

      function updateToc() {
        tocList.innerHTML = "";
        const headings = editor.querySelectorAll('.block[data-type="heading"]');
        if (headings.length === 0) {
          tocList.innerHTML =
            '<li><a href="#" style="color:#999; pointer-events:none;">æš‚æ— æ ‡é¢˜</a></li>';
          return;
        }
        headings.forEach((headingBlock, index) => {
          const contentEl = headingBlock.querySelector(".content");
          const numberSpan = headingBlock.querySelector(".heading-number");
          if (!contentEl || !numberSpan) return;

          const id = headingBlock.id || `heading-${index}-${Date.now()}`;
          headingBlock.id = id;

          const level = (numberSpan.textContent.match(/\./g) || []).length + 1;

          const li = document.createElement("li");
          const a = document.createElement("a");
          a.href = `#${id}`;
          a.textContent = `${numberSpan.textContent} ${contentEl.textContent}`;
          a.className = `toc-level-${level}`;
          li.appendChild(a);
          tocList.appendChild(li);
        });
      }

      document.getElementById("toc-panel").addEventListener("click", (e) => {
        if (e.target.tagName === "A" && e.target.hash) {
          e.preventDefault();
          const targetId = e.target.hash.substring(1);
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            let parent = targetElement.parentElement;
            while (parent) {
              if (parent.tagName === "DETAILS" && !parent.open) {
                parent.open = true;
              }
              parent = parent.parentElement;
            }
            targetElement.scrollIntoView({
              behavior: "smooth",
              block: "start",
            });
          }
        }
      });
    </script>
    <!-- åˆå§‹åŒ–ä¸ç»“æŸå·¥ä½œ -->
    <script>
      initColorPalette();
      //å¦‚æœæ²¡æœ‰localstorageçš„å‚¨å­˜,åˆ™è‡ªåŠ¨åŠ å…¥ä¸€ä¸ªå†…å®¹

      if (!loadEditorState()) {
        const h1 = createBlock("heading", "ğŸ¤ªJI_tionç¼–è¾‘å™¨ğŸ¤ª", {
          level: 2,
          openState: true,
        });
        const p1 = createBlock(
          "p",
          "åœ¨ä»»æ„æ–‡æœ¬å—å†…è¾“å…¥ `` ` `` (ä¸¤ä¸ªåå¼•å·)å¯ä»¥è°ƒå‡ºå‘½ä»¤èœå•ã€‚æ‹–æ‹½æ ‡é¢˜å·¦ä¾§çš„ä¸‰è§’å½¢å¯ä»¥æŠ˜å /å±•å¼€å†…å®¹ã€‚"
        );
        const h2 = createBlock("heading", "æ ‡é¢˜", {
          level: 3,
          openState: true,
        });
        const p2 = createBlock("p", "ä¸‹é¢æ¼”ç¤ºåˆ—è¡¨ã€ä»»åŠ¡ã€ä»£ç ä¸è¡¨æ ¼ï¼š");
        const ul = createBlock("ul");
        ul.querySelector(".block-children").appendChild(
          createBlock("li", "æ— åºåˆ—è¡¨é¡¹ A")
        );
        ul.querySelector(".block-children").appendChild(
          createBlock("li", "æ— åºåˆ—è¡¨é¡¹ B")
        );
        const task = createBlock("task");
        task
          .querySelector(".block-children")
          .appendChild(createBlock("taskitem", "ä»»åŠ¡é¡¹ 1", { checked: false }));
        task
          .querySelector(".block-children")
          .appendChild(createBlock("taskitem", "ä»»åŠ¡é¡¹ 2", { checked: true }));
        const pre = createBlock("pre", "", {
          content: 'console.log("Hello, collapsible code block!");',
          lang: "javascript",
        });
        const table = createBlock("table");
        const h3 = createBlock("heading", "è¿™æ˜¯ä¸€ä¸ªä¸‰çº§æ ‡é¢˜", { level: 4 });
        const p3 = createBlock("p", "è¿™æ˜¯ä¸‰çº§æ ‡é¢˜ä¸‹çš„å†…å®¹ã€‚");

        editor.appendChild(h1);
        const h1_children = h1.querySelector(".block-children");
        h1_children.appendChild(p1);
        h1_children.appendChild(h2);

        const h2_children = h2.querySelector(".block-children");
        h2_children.appendChild(p2);
        h2_children.appendChild(ul);
        h2_children.appendChild(task);
        h2_children.appendChild(pre);
        h2_children.appendChild(table);
        h2_children.appendChild(h3);

        const h3_children = h3.querySelector(".block-children");
        h3_children.appendChild(p3);

        updateAllHeadingNumbers();
        saveEditorState();
      }
      //windowæŒ‡çš„æ˜¯æ•´ä¸ªæµè§ˆå™¨
      //documentå€¼å¾—æ˜¯å½“å‰ç½‘é¡µ
      //beforeunload æ˜¯æµè§ˆå™¨äº‹ä»¶ï¼Œå½“ç”¨æˆ·å…³é—­ã€åˆ·æ–°é¡µé¢æˆ–è·³è½¬æ—¶è§¦å‘ã€‚
      // saveEditorState æ˜¯ä½ å®šä¹‰çš„å‡½æ•°ï¼Œç”¨æ¥ä¿å­˜å½“å‰ç¼–è¾‘å™¨å†…å®¹åˆ°æœ¬åœ°ç¼“å­˜æˆ–æœåŠ¡å™¨ã€‚
      // ä½œç”¨ï¼šé˜²æ­¢æœªä¿å­˜çš„å†…å®¹ä¸¢å¤±ã€‚
      window.addEventListener("beforeunload", saveEditorState);
      // å¦‚æœä½¿ç”¨ctrl+s,ä¿å­˜ä¸ºhtml
      document.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s") {
          e.preventDefault();
          downloadHTML();
        }
      });
      window._undo = undo;
      window._redo = redo;
      window._save = saveEditorState;
      window._exportMD = exportToMarkdown;
    </script>
  </body>
</html>
